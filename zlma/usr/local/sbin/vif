#!/usr/bin/env python3
#
# vif - Resuscitation of the z/VM "Virtual Image Facility" originally released in 2000
#
import argparse
import json
import logging
import subprocess
import sys
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import List, Optional, Dict, Any, Union
from enum import Enum
from zlma_conf import Zlma_conf
import requests
import json
import os



class CommandType(Enum):
    # Enumeration of main command types
    HYP = "hyp"
    IMAGE = "image"
    VM = "vm"
    DISK = "disk"
    QUERY = "query"


@dataclass
class ParsedCommand:
    # Data class representing a parsed VIF command
    command_type: CommandType
    action: str
    target: Optional[str] = None
    arguments: List[str] = None
    options: Dict[str, Any] = None

    def __post_init__(self):
        if self.arguments is None:
            self.arguments = []
        if self.options is None:
            self.options = {}


class CommandParser(ABC):
    # Abstract base class for command parsers
    
    @abstractmethod
    def can_parse(self, tokens: List[str]) -> bool:
        # Check if this parser can handle the given tokens
        pass
    
    @abstractmethod
    def parse(self, tokens: List[str]) -> ParsedCommand:
        # Parse the tokens into a ParsedCommand
        pass


class HypParser(CommandParser):
    # Parser for hypervisor commands
    
    VALID_ACTIONS = {
        'collect': 'Return problem determination',
        'disk': 'Add paging or Linux disk space',
        'errors': 'Return hardware errors',
        'restart': 'SHUTDOWN REIPL',
        'service': 'z/VM Dvlpmnt needs to enable this to modernize z/VM',
        'shutdown': 'SHUTDOWN',
        'verify': 'Perform z/VM consistency checks'
    }
    
    def can_parse(self, tokens: List[str]) -> bool:
        return len(tokens) >= 2 and tokens[0] == 'hyp'
    
    def parse(self, tokens: List[str]) -> ParsedCommand:
        if not self.can_parse(tokens):
            raise ValueError("Cannot parse as hyp command")
        
        action = tokens[1]
        if action not in self.VALID_ACTIONS:
            raise ValueError(f"Invalid hyp action: {action}")
        
        cmd = ParsedCommand(
            command_type=CommandType.HYP,
            action=action,
            arguments=tokens[2:] if len(tokens) > 2 else []
        )
        
        # Special handling for disk commands
        if action == 'disk' and len(tokens) >= 5:
            cmd.options = {
                'operation': tokens[2],  # add
                'type': tokens[3],       # image/paging
                'identifier': tokens[4]  # 1234/abcd
            }
        
        return cmd


class ImageParser(CommandParser):
    # Parser for image commands
    
    VALID_ACTIONS = {
        'create': 'Create a new Linux golden image',
        'delete': 'Delete a Linux golden image'
    }
    
    def can_parse(self, tokens: List[str]) -> bool:
        return len(tokens) >= 2 and tokens[0] == 'image'
    
    def parse(self, tokens: List[str]) -> ParsedCommand:
        if not self.can_parse(tokens):
            raise ValueError("Cannot parse as image command")
        
        action = tokens[1]
        if action not in self.VALID_ACTIONS:
            raise ValueError(f"Invalid image action: {action}")
        
        return ParsedCommand(
            command_type=CommandType.IMAGE,
            action=action,
            arguments=tokens[2:] if len(tokens) > 2 else []
        )


class VmParser(CommandParser):
    # Parser for VM commands
    
    VALID_ACTIONS = {
        'create': 'Clone a Linux',
        'delete': 'Delete Linux but no PURGE just yet',
        'list': 'List all VMs and their status',
        'network': 'Add OSA triplet - need VSWITCH name as an arg?',
        'set': 'Set VM properties (storage/cpus)',
        'start': 'Start VM',
        'stop': 'Stop VM',
        'stopall': 'Loop through all images and call image stop on them'
    }
    
    def can_parse(self, tokens: List[str]) -> bool:
        return len(tokens) >= 2 and tokens[0] == 'vm'
    
    def parse(self, tokens: List[str]) -> ParsedCommand:
        if not self.can_parse(tokens):
            raise ValueError("Cannot parse as vm command")
        
        action = tokens[1]
        
        # Handle special cases
        if action == 'stopall':
            return ParsedCommand(
                command_type=CommandType.VM,
                action=action
            )
        
        if action not in self.VALID_ACTIONS:
            raise ValueError(f"Invalid vm action: {action}")
        
        cmd = ParsedCommand(
            command_type=CommandType.VM,
            action=action,
            arguments=tokens[2:] if len(tokens) > 2 else []
        )
        
        # Special parsing for different VM actions
        if action in ['create', 'delete', 'start', 'stop'] and len(tokens) >= 3:
            cmd.target = tokens[2]  # VM name
            cmd.arguments = tokens[3:]
        
        elif action == 'network' and len(tokens) >= 5:
            cmd.target = tokens[2]  # VM name
            cmd.options = {
                'operation': tokens[3],  # add
                'network_id': tokens[4]  # 360
            }
            cmd.arguments = tokens[5:]
        
        elif action == 'set' and len(tokens) >= 5:
            cmd.target = tokens[2]  # VM name
            cmd.options = {
                'property': tokens[3],   # storage/cpus
                'value': tokens[4]       # 8/4
            }
            cmd.arguments = tokens[5:]
        
        return cmd


class DiskParser(CommandParser):
    # Parser for disk commands
    
    VALID_ACTIONS = {
        'copy': 'Copy a disk from one VM to another',
        'create': 'Create a new disk for a VM',
        'delete': 'Delete a disk from a VM',
        'share': 'Share disk between two VMs (low priority)'
    }
    
    def can_parse(self, tokens: List[str]) -> bool:
        return len(tokens) >= 2 and tokens[0] == 'disk'
    
    def parse(self, tokens: List[str]) -> ParsedCommand:
        if not self.can_parse(tokens):
            raise ValueError("Cannot parse as disk command")
        
        action = tokens[1]
        if action not in self.VALID_ACTIONS:
            raise ValueError(f"Invalid disk action: {action}")
        
        cmd = ParsedCommand(
            command_type=CommandType.DISK,
            action=action,
            arguments=tokens[2:] if len(tokens) > 2 else []
        )
        
        # Special parsing for different disk actions
        if action == 'copy' and len(tokens) >= 6:
            # disk copy linux1 150 [to] linux2 150
            to_index = None
            if 'to' in tokens:
                to_index = tokens.index('to')
                cmd.options = {
                    'source_vm': tokens[2],
                    'source_disk': tokens[3],
                    'target_vm': tokens[to_index + 1],
                    'target_disk': tokens[to_index + 2]
                }
            elif len(tokens) >= 6:
                cmd.options = {
                    'source_vm': tokens[2],
                    'source_disk': tokens[3],
                    'target_vm': tokens[4],
                    'target_disk': tokens[5]
                }
        
        elif action == 'create' and len(tokens) >= 5:
            # disk create linux1 150 2G
            cmd.options = {
                'vm': tokens[2],
                'disk_id': tokens[3],
                'size': tokens[4]
            }
        
        elif action == 'delete' and len(tokens) >= 4:
            # disk delete linux1 150
            cmd.options = {
                'vm': tokens[2],
                'disk_id': tokens[3]
            }
        
        elif action == 'share' and len(tokens) >= 6:
            # disk share linux1 151 linux2 151
            cmd.options = {
                'source_vm': tokens[2],
                'source_disk': tokens[3],
                'target_vm': tokens[4],
                'target_disk': tokens[5]
            }
        
        return cmd


class QueryParser(CommandParser):
    # Parser for query commands
    
    VALID_ACTIONS = {
        'active': 'Report which VMs are running',
        'all': 'Invoke all other query subcommands',
        'configuration': 'Display current vif settings',
        'disks': 'Display VM DASD utilization',
        'errors': 'Write errors to /var/log/zlma/errors.report.<timestamp>',
        'version': 'Report the vif version',
        'network': 'Display network configuration',
        'paging': 'Show page space and % used',
        'performance': 'Display current CPU, paging and I/O utilization',
        'shared': 'Display VMs that share disks',
        'vm': 'Display configuration of a VM',
        'volumes': 'Display image and paging DASD volumes'
    }
    
    def can_parse(self, tokens: List[str]) -> bool:
        return len(tokens) >= 2 and tokens[0] == 'query'
    
    def parse(self, tokens: List[str]) -> ParsedCommand:
        if not self.can_parse(tokens):
            raise ValueError("Cannot parse as query command")
        
        action = tokens[1]
        if action not in self.VALID_ACTIONS:
            raise ValueError(f"Invalid query action: {action}")
        
        return ParsedCommand(
            command_type=CommandType.QUERY,
            action=action,
            arguments=tokens[2:] if len(tokens) > 2 else []
        )

class VifCommandParser:
    # Main VIF command parser that coordinates all sub-parsers
    
    def __init__(self):
        self.parsers = [
            HypParser(),
            ImageParser(),
            VmParser(),
            DiskParser(),
            QueryParser()
        ]
    
    def tokenize(self, command: str) -> List[str]:
        # Tokenize a command string into a list of tokens
        # Simple whitespace tokenization for now
        return command.strip().split()
    
    def parse(self, command: str) -> ParsedCommand:
        # Parse a complete VIF command string
        # Handle the 'vif' prefix if present
        if command.strip().startswith('vif '):
            command = command[4:].strip()
        
        tokens = self.tokenize(command)
        
        if not tokens:
            raise ValueError("Empty command")
        
        # Try each parser until one can handle the command
        for parser in self.parsers:
            if parser.can_parse(tokens):
                return parser.parse(tokens)
        
        raise ValueError(f"No parser found for command: {' '.join(tokens)}")
    
    def validate_command(self, command: str) -> bool:
        # Validate if a command can be parsed without raising exceptions
        try:
            self.parse(command)
            return True
        except ValueError:
            return False


class Vif:
  # Process all VIF commands using modern object-oriented parser
  
  def __init__(self):
    self.conf = Zlma_conf()                # configuration variables
    self.conf.load_config_file()           # read the config file
    logging.basicConfig(filename='/var/log/zlma/vif.log', format='%(asctime)s %(levelname)s %(message)s')
    self.console = logging.StreamHandler() # set up logging to console
    self.formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s') # format is simpler for console use
    self.console.setFormatter(self.formatter)
    logging.getLogger('').addHandler(self.console) # add the handler to the root logger
    self.log = logging.getLogger(__name__)
    self.lpar = None                       # LPAR we are running on
    self.user_id = None                    # User ID we are running in
    
    # set feilong_url from config file
    self.feilong_url = self.conf.feilong_url

    # set log level on the console and to log files
    self.log.debug(f"__init__() user:{self.conf.user} setting log level to {self.conf.log_level}")
    self.console.setLevel(self.conf.log_level)
    self.log.setLevel(self.conf.log_level)

    # parse args passed in
    self.parser = argparse.ArgumentParser(description="The vif command line interface")
    self.parser.add_argument("cmd", type=str, help="The vif command to be executed (vif helpall)", nargs=argparse.REMAINDER) 
    self.parser.add_argument("-v", "--verbose", help="increase output verbosity", action="store_true")
    self.parser.add_argument("-l", "--lpar", help="LPAR image is on", action="append")
    self.args = self.parser.parse_args()
    
    # Initialize the new VIF command parser
    self.vif_parser = VifCommandParser()

  def run_vm_cmd(self, cp_cmd: str):      # run a CP command using vmcp
    cmd = f"sudo /usr/sbin/vmcp {cp_cmd}"
    self.log.debug(f"run_vm_cmd() running CP cmd: {cmd}")
    try:
      result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
    except subprocess.CalledProcessError as e:
      self.log.error(f"run_vm_cmd(): cmd {cmd} returned subprocess exception: {e}")
      sys.exit(1)
    vmcp_out = result.stdout
    #print(vmcp_out)
    return vmcp_out

  def check_lpar(self, tgt_lpar: str):
    self.get_lpar_userid()
    if tgt_lpar != self.lpar:              # not running on requested LPAR 
      # TO DO: run vif on the target LPAR rather than faile
      self.log.error(f"check_lpar(): current LPAR: {self.lpar} requesed LPAR: {tgt_lpar}")
      sys.exit(1)

  # TO DO: delete if priv class will be only 'G'
  #def check_privclas(self, class_to_check: str):
  #  cmd = f"/usr/local/sbin/qprivclas {class_to_check}"
  #  try:
  #    result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
  #  except subprocess.CalledProcessError as e:
  #    self.log.error(f"check_privclas(): cmd {cmd} returned subprocess exception: {e}")
  #    sys.exit(1)
  #  self.log.debug(f"rc from {cmd}: {result.returncode}")
  #  return int(result.returncode)

  def dispatch_command(self, parsed_cmd: ParsedCommand):
    # Dispatch parsed command to appropriate handler based on command type and action
    if parsed_cmd.command_type == CommandType.HYP:
      self.handle_hyp_command(parsed_cmd)
    elif parsed_cmd.command_type == CommandType.IMAGE:
      self.handle_image_command(parsed_cmd)
    elif parsed_cmd.command_type == CommandType.VM:
      self.handle_vm_command(parsed_cmd)
    elif parsed_cmd.command_type == CommandType.DISK:
      self.handle_disk_command(parsed_cmd)
    elif parsed_cmd.command_type == CommandType.QUERY:
      self.handle_query_command(parsed_cmd)
    else:
      self.log.error(f"Unknown command type: {parsed_cmd.command_type}")
      sys.exit(1)

  def handle_hyp_command(self, cmd: ParsedCommand):
    # Handle hypervisor commands
    match cmd.action:
      case 'collect':
        self.handle_hyp_collect()
      case 'disk':
        if cmd.options:
          args = f"{cmd.options['operation']} {cmd.options['type']} {cmd.options['identifier']}"
          self.handle_hyp_disk(args)
        else:
          self.handle_hyp_disk(' '.join(cmd.arguments))
      case 'errors':
        self.handle_hyp_errors()
      case 'restart':
        self.handle_hyp_shutdown("restart")
      case 'service':
        self.handle_hyp_service()
      case 'shutdown':
        self.handle_hyp_shutdown("shutdown")
      case 'verify':
        self.handle_hyp_verify()
      case _:
        self.log.error(f"Unknown hyp action: {cmd.action}")
        sys.exit(1)

  def handle_image_command(self, cmd: ParsedCommand):
    # Handle image commands
    match cmd.action:
      case 'create':
        self.handle_image_create(cmd.arguments)
      case 'delete':
        if cmd.arguments:
          self.handle_image_delete(cmd.arguments[0])
        else:
          self.log.error("Image delete requires an image name")
          sys.exit(1)
      case _:
        self.log.error(f"Unknown image action: {cmd.action}")
        sys.exit(1)

  def handle_vm_command(self, cmd: ParsedCommand):
    # Handle VM commands
    match cmd.action:
      case 'create':
        self.handle_vm_create(cmd.target, cmd.arguments)
      case 'delete':
        self.handle_vm_delete(cmd.target, cmd.arguments)
      case 'list':
        self.handle_vm_list(cmd.arguments)
      case 'network':
        self.handle_vm_network(cmd.target, cmd.options, cmd.arguments)
      case 'set':
        self.handle_vm_set(cmd.target, cmd.options, cmd.arguments)
      case 'start':
        self.handle_vm_start(cmd.target, cmd.arguments)
      case 'stop':
        self.handle_vm_stop(cmd.target, cmd.arguments)
      case 'stopall':
        self.handle_vm_stopall()
      case _:
        self.log.error(f"Unknown vm action: {cmd.action}")
        sys.exit(1)

  def handle_disk_command(self, cmd: ParsedCommand):
    # Handle disk commands
    match cmd.action:
      case 'copy':
        self.handle_disk_copy_new(cmd.options)
      case 'create':
        self.handle_disk_create_new(cmd.options)
      case 'delete':
        self.handle_disk_delete_new(cmd.options)
      case 'share':
        self.handle_disk_share_new(cmd.options)
      case _:
        self.log.error(f"Unknown disk action: {cmd.action}")
        sys.exit(1)

  def handle_query_command(self, cmd: ParsedCommand):
    # Handle query commands
    match cmd.action:
      case 'active':
        self.handle_query_active()
      case 'all':
        self.handle_query_all()
      case 'configuration':
        self.handle_query_configuration()
      case 'disks':
        self.handle_query_disks()
      case 'errors':
        self.handle_query_errors()
      case 'version':
        self.handle_query_version()
      case 'network':
        self.handle_query_network()
      case 'paging':
        self.handle_query_paging()
      case 'performance':
        self.handle_query_performance()
      case 'shared':
        self.handle_query_shared()
      case 'vm':
        if cmd.arguments:
          self.handle_query_vm(cmd.arguments[0])
        else:
          self.log.error("Query vm requires a VM name")
          sys.exit(1)
      case 'volumes':
        self.handle_query_volumes()
      case _:
        self.log.error(f"Unknown query action: {cmd.action}")
        sys.exit(1) 

  def get_lpar_userid(self):               # get LPAR and user ID we are running on
    vmcp_out = self.run_vm_cmd("QUERY USERID")
    #print(f"vmcp_out: {vmcp_out}")
    words = vmcp_out.split()               # split string into words
    self.lpar = words[2] 
    self.user_id = words[0] 
    self.log.debug(f"get_lpar_userid() lpar: {self.lpar} user_id: {self.user_id}")

  # 'vif help' command handlers
  def handle_help_all(self):
    self.log.debug(f"handle_help_all(): user: {self.conf.user}")
    self.handle_help()
    print()
    self.handle_help_hypervisor()
    print()
    self.handle_help_image()
    print()
    self.handle_help_vm()
    print()
    self.handle_help_disk()
    print()
    self.handle_help_query()

  def handle_help_hypervisor(self):
    self.log.debug(f"handle_help_hypervisor(): user: {self.conf.user}")
    print("vif hypervisor: manage and maintain z/VM")
    print("  Subcommands:")
    print("      collect: create report on z/VM problem determination info")
    print("               Syntax: vif hyp collect.")
    print("         disk: add paging or image disk space ")
    print("               Syntax: vif hyp disk add (image|paging) <id>.")
    print("       errors: create report on hardware errors")
    print("               Syntax: vif hyp errors.")
    print("      restart: SHUTDOWN REIPL z/VM")
    print("               Syntax: vif hyp restart.")
    print("      service: install the latest VIF service (git pull?)")
    print("               Syntax: vif hyp service.")
    print("     shutdown: SHUTDOWN z/VM")
    print("               Syntax: vif hyp shutdown.")
    print("       verify: performs consistency checks of vif")
    print("               Syntax: vif hyp verify.")

  def handle_help_image(self):
    self.log.debug(f"handle_help_image(): user: {self.conf.user}")
    print("vif image    : manage Linux golden images")
    print("  Subcommands:")
    print("       create: create a new Linux golden image")
    print("               Syntax: vif image create [<template>]")
    print("       delete: delete a Linux golden image")
    print("               Syntax: vif image delete [<image>]")

  def handle_help_vm(self):
    self.log.debug(f"handle_help_vm(): user: {self.conf.user}")
    print("vif vm       : manage Linux VM instances")
    print("  Subcommands:")
    print("       create: clone a Linux VM")
    print("               Syntax: vif vm create <vm_name>")
    print("       delete: delete Linux VM (no PURGE just yet)")
    print("               Syntax: vif vm delete <vm_name>")
    print("         list: list all VMs and their status")
    print("               Syntax: vif vm list")
    print("      network: add OSA triplet - need VSWITCH name as an arg?")
    print("               Syntax: vif vm network <vm_name> add <device>")
    print("          set: change memory size or number of CPUs of a VM")
    print("               Syntax: vif vm set <vm_name> cpus <count>  (count: 1-4)")
    print("               Syntax: vif vm set <vm_name> memory <gb>  (gb: 1, 2, 3, 4)")
    print("        start: start a VM")
    print("               Syntax: vif vm start <vm_name>")
    print("         stop: stop a VM")
    print("               Syntax: vif vm stop <vm_name>")
    print("      stopall: stop all VMs on LPAR")
    print("               Syntax: vif vm stopall")

  def handle_help_disk(self):
    self.log.debug(f"handle_help_disk(): user: {self.conf.user}")
    print("vif disk: manage disks")
    print("  Subcommands:")
    print("         copy: copy source disk to newly added target disk")
    print("               Syntax: vif disk copy <vm1> <device1> [to] <vm2> <device2>")
    print("       create: add a new disk")
    print("               Syntax: vif disk create <vm> <device> <size>")
    print("       delete: delete an existing disk")
    print("               Syntax: vif disk delete <vm1> <device1>")
    print("        share: give read-only access to the disk of another VM")
    print("               Syntax: vif disk share <vm1> <device1> [with] <vm2> <device2>")
   
  def handle_help_query(self):
    self.log.debug(f"handle_help_query(): user: {self.conf.user}")
    print("vif query    : display many types of z/VM information")
    print("  Subcommands:")
    print("       active: report which VMs are running")
    print("          all: invoke all other query subcommands")
    print("configuration: display current vif settings")
    print("        disks: display VM DASD utilization")
    print("       errors: report on hardware errors")
    print("       version: report the vif version")
    print("      network: display network configuration")
    print("       paging: report on amount of page space and how much is being used")
    print("  performance: display current CPU, paging and I/O utilization")
    print("       shared: display VMs that share disks")
    print("           vm: display configuration of a VM")
    print("               Syntax: vif query vm <vm_name>")
    print("      volumes: display image and paging DASD volumes")

  def handle_help(self):
    self.log.debug(f"handle_help(): user: {self.conf.user}")
    print(" vif commands:")
    print("         disk: manage disks")
    print("         help: give help")
    print("   hypervisor: manage z/VM (alias: hyp)")
    print("        image: manage Linux golden images")
    print("        query: display many types of z/VM information")
    print("           vm: manage Linux VM instances")

  # 'vif hypervisor' command handlers
  def handle_hyp_collect(self):
    # call script hypcollect to collect z/VM and Linux data
    self.log.debug(f"handle_hyp_collect(): user: {self.conf.user}  Write problem determination data to <timestamp>")
    print("calling hypcollect ...")
    cmd = "/usr/local/sbin/hypcollect"
    try:
      result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
    except Exception as e:
      print(f"handle_hyp_collect(): Exception calling zlma: {e}")
      exit(3)
    print(f"{result.stdout}")              # show the output

  def handle_hyp_disk(self, args: str):
    cmd = f"VIFCMS hyp {args}"
    self.log.debug(f"handle_hyp_disk(): user: {self.conf.user} cmd: {cmd}") 
    print(f"call: '{cmd}'")

  def handle_hyp_errors(self):
    cmd = f"VIFCMS hyp errors"
    self.log.debug(f"handle_hyp_errors(): user: {self.conf.user} write hardware errors to /var/log/zlma/ereprept.YY-MM-DD-HH:MM:SS")
    print("call: 'VIFCMS hyp errors' => return hardware errors /var/log/zlma/error.report.<timestamp>")

  def handle_hyp_service(self):
    self.log.debug(f"handle_hyp_service(): user: {self.conf.user} how to service z/VM from Linux?")
    print("call: 'VIFCMS hyp service' => z/VM Dvlpmnt needs to enable this to modernize z/VM")

  def handle_hyp_shutdown(self, flavor: str):
    # hypervisor 'restart' and 'shutdown' both invoke CP SHUTDOWN
    self.log.debug(f"handle_hyp_shutdown(): user: {self.conf.user} run 'CP SHUTDOWN'")
    if flavor == "restart":
      print(f"ERROR: You cannot SHUTDOWN REIPL z/VM from a browser!!!")
    else:
      print(f"ERROR: You cannot SHUTDOWN z/VM from a browser!!!")

  def handle_hyp_verify(self):
    self.log.debug(f"handle_hyp_verify(): user: {self.conf.user} do consistency checks, args FULL, BRIef, or NETwork <image>'")
    print("call: 'VIFCMS hyp verify' => perform z/VM consistency checks")

  # New VM command handlers
  def handle_vm_create(self, vm_name: str, args: List[str]):
    # Enhanced VM creation handler with image deployment support
    self.log.debug(f"handle_vm_create(): user: {self.conf.user} clone Linux vm: {vm_name}")
    
    # Parse additional arguments from the web form
    params = {}
    i = 0
    while i < len(args):
      if args[i] == '--memory' and i + 1 < len(args):
        params['memory'] = args[i + 1]
        i += 2
      elif args[i] == '--cpus' and i + 1 < len(args):
        params['cpus'] = args[i + 1]
        i += 2
      elif args[i] == '--image' and i + 1 < len(args):
        params['image'] = args[i + 1]
        i += 2
      elif args[i] == '--architecture' and i + 1 < len(args):
        params['architecture'] = args[i + 1]
        i += 2
      else:
        i += 1
    
    # Set defaults if not provided
    cpus = int(params.get('cpus', '1'))
    memory = params.get('memory', '1024')  # in MB
    image = params.get('image', 'sles15sp6-minimal')
    architecture = params.get('architecture', 's390x')
    
    # Validate inputs
    if architecture != 's390x':
      print(f"Error: Only s390x architecture is supported, got: {architecture}")
      return
      
    if cpus < 1 or cpus > 4:
      print(f"Error: CPU count must be between 1 and 4, got: {cpus}")
      return
      
    try:
      memory_mb = int(memory)
      if memory_mb < 512 or memory_mb > 4096:
        print(f"Error: Memory must be between 512MB and 4096MB, got: {memory_mb}MB")
        return
    except ValueError:
      print(f"Error: Invalid memory value: {memory}")
      return
    
    print(f"Creating VM '{vm_name}' with {cpus} CPUs, {memory_mb}MB memory...")
    print(f"Base image: {image}")
    
    # Step 1: Create the VM definition
    vm_config = {
      "guest": {
        "userid": vm_name.upper(),
        "vcpus": cpus,
        "memory": memory_mb,
        "max_cpu": 4,
        "max_mem": "4G",
        "user_profile": "LINDFLT",
        "disk_list": [
        {
          "size": "8g",
          "is_boot_disk": True,
          "disk_pool": "ECKD:VMPOOL"
        },
     ],

      }
    }
    
    try:
      # Create the VM
      print("Step 1: Creating VM definition...")
      response = requests.post(
        f"{self.feilong_url}/guests",
        json=vm_config,
        headers={'Content-Type': 'application/json'},
        timeout=60
      )
      
      if response.status_code not in [200, 201]:
        print(f"✗ VM creation failed with status code: {response.status_code}")
        try:
          error_details = response.json()
          print(f"Error details: {json.dumps(error_details, indent=2)}")
        except:
          print(f"Error response: {response.text}")
        return
      
      print(f"✓ VM '{vm_name}' definition created successfully!")
      
      # Step 2: Deploy the image to the VM
      print("Step 2: Deploying base image to VM...")
      deploy_config = {
        "image": image,
      }
      
      deploy_response = requests.post(
        f"{self.feilong_url}/guests/{vm_name.upper()}/action",
        json={
          "action": "deploy", 
          **deploy_config
        },
        headers={'Content-Type': 'application/json'},
        timeout=2400 # doubling the timeout for image deployment
      )
      
      if deploy_response.status_code == 200:
        print(f"✓ Base image '{image}' deployed successfully to VM '{vm_name}'!")
      else:
        print(f"⚠ Image deployment failed with status code: {deploy_response.status_code}")
        try:
          error_details = deploy_response.json()
          print(f"Deploy error details: {json.dumps(error_details, indent=2)}")
        except:
          print(f"Deploy error response: {deploy_response.text}")
        print("VM created but without base image. You may need to deploy manually.")
        return
      
      # Step 3: Start the VM
      print("Step 3: Starting VM...")
      start_response = requests.post(
        f"{self.feilong_url}/guests/{vm_name.upper()}/action",
        json={"action": "start"},
        headers={'Content-Type': 'application/json'},
        timeout=60
      )
      
      if start_response.status_code == 200:
        print(f"✓ VM '{vm_name}' started successfully!")
        print(f"")
        print(f"VM '{vm_name}' is now ready for use!")
        print(f"- CPUs: {cpus}")
        print(f"- Memory: {memory_mb}MB")
        print(f"- Base Image: {image}")
        print(f"- Status: Running")
        # add the VM to zlma
        rc = subprocess.run(f"zlma add --server {vm_name} --copyscript", shell=True)
        if rc.returncode == 0:
          print(f"✓ VM '{vm_name}' added to zlma successfully!")
        else:
          print(f"✗ Failed to add VM '{vm_name}' to zlma. Please check the script.")
      else:
        print(f"⚠ VM created and image deployed, but failed to start automatically.")
        print(f"You can start it manually with: vif vm start {vm_name}")
          
    except requests.exceptions.ConnectTimeout:
      print("✗ Connection to Feilong API timed out")
    except requests.exceptions.ConnectionError:
      print("✗ Cannot connect to Feilong API. Please check if the service is running.")
    except Exception as e:
      print(f"✗ Unexpected error: {e}")

  def handle_vm_delete(self, vm_name: str, args: List[str]):
    # Enhanced VM deletion handler using Feilong API
    self.log.debug(f"handle_vm_delete(): user: {self.conf.user} delete Linux vm: {vm_name}")
    
    if not vm_name:
      print("Error: VM name is required for deletion")
      return
    
    print(f"Deleting VM '{vm_name}'...")
    
    try:
      # Call Feilong API to delete the guest
      response = requests.delete(
        f"{self.feilong_url}/guests/{vm_name.upper()}",
        timeout=60
      )
      
      if response.status_code == 200:
        print(f"✓ VM '{vm_name}' deleted successfully!")
        self.log.info(f"VM '{vm_name}' deleted successfully via Feilong API")
        rc = subprocess.run(f"zlma remove --server {vm_name}", shell=True)
        if rc.returncode == 0:
          print(f"✓ VM '{vm_name}' removed from zlma successfully!")
        else:
          print(f"✗ Failed to remove VM '{vm_name}' from zlma. Please check the script.")
      else:
        print(f"✗ Failed to delete VM '{vm_name}'")
        print(f"HTTP Status Code: {response.status_code}")
        try:
          error_details = response.json()
          print(f"Error details: {json.dumps(error_details, indent=2)}")
        except:
          print(f"Error response: {response.text}")
        self.log.error(f"Failed to delete VM '{vm_name}': HTTP {response.status_code}")
        
    except requests.exceptions.ConnectTimeout:
      print("✗ Connection to Feilong API timed out")
      self.log.error(f"Timeout while deleting VM '{vm_name}'")
    except requests.exceptions.ConnectionError:
      print("✗ Cannot connect to Feilong API. Please check if the service is running.")
      self.log.error(f"Connection error while deleting VM '{vm_name}'")
    except Exception as e:
      print(f"✗ Unexpected error: {e}")
      self.log.error(f"Unexpected error while deleting VM '{vm_name}': {e}")

  def handle_vm_network(self, vm_name: str, options: Dict[str, Any], args: List[str]):
    if options:
      operation = options.get('operation', '')
      network_id = options.get('network_id', '')
      self.log.debug(f"handle_vm_network(): user: {self.conf.user} vm: {vm_name} {operation} network {network_id}")
      print(f"call: 'VIFCMS vm network {vm_name} {operation} {network_id}' => add OSA triplet - need VSWITCH name as an arg?")
    else:
      args_str = ' '.join(args)
      self.log.debug(f"handle_vm_network(): user: {self.conf.user} vm: {vm_name} args: {args_str}")
      print(f"call: 'VIFCMS vm network {vm_name} {args_str}' => add OSA triplet - need VSWITCH name as an arg?")

  def handle_vm_set(self, vm_name: str, options: Dict[str, Any], args: List[str]):
    """
    Set VM properties: CPU count or memory size
    Syntax: vif vm set <vm_name> cpus <count>  (count: 1-4)
    Syntax: vif vm set <vm_name> memory <gb>  (gb: 1, 2, 3, 4)
    """
    self.log.debug(f"handle_vm_set(): user: {self.conf.user} vm: {vm_name}")
    
    if not vm_name:
      print("Error: VM name is required")
      return
    
    # Parse arguments - either from options or args
    property_type = None
    value = None
    
    if options:
      # From structured parser
      property_type = options.get('property', '').lower()
      value = options.get('value', '')
    elif len(args) >= 2:
      # From simple args: ['cpus', '2'] or ['memory', '2048']
      property_type = args[0].lower()
      value = args[1]
    else:
      print("Error: Invalid syntax")
      print("Usage: vif vm set <vm_name> cpus <count>")
      print("       vif vm set <vm_name> memory <gb>")
      return
    
    if property_type == 'cpus':
      self._resize_vm_cpus(vm_name, value)
    elif property_type == 'memory':
      self._resize_vm_memory(vm_name, value)
    else:
      print(f"Error: Unknown property '{property_type}'")
      print("Supported properties: cpus, memory")
  
  def _resize_vm_cpus(self, vm_name: str, cpu_count: str):
    """Resize VM CPU count using Feilong API"""
    try:
      cpu_cnt = int(cpu_count)
      
      if cpu_cnt < 1 or cpu_cnt > 4:
        print(f"Error: CPU count must be between 1 and 4, got: {cpu_cnt}")
        return
      
      print(f"Resizing VM '{vm_name}' to {cpu_cnt} CPUs...")
      
      response = requests.post(
        f"{self.feilong_url}/guests/{vm_name.upper()}/action",
        json={
          "action": "resize_cpus",
          "cpu_cnt": cpu_cnt
        },
        headers={'Content-Type': 'application/json'},
        timeout=60
      )
      
      if response.status_code == 200:
        print(f"✓ VM '{vm_name}' CPU count changed to {cpu_cnt}")
        print("Note: Changes take effect after VM restart")
        
        # Update ZLMA database after successful CPU change
        try:
          print("Updating ZLMA database...")
          zlma_result = subprocess.run("/usr/local/sbin/zlma update", shell=True, capture_output=True, text=True, timeout=30)
          if zlma_result.returncode == 0:
            print("✓ ZLMA database updated successfully")
          else:
            print(f"⚠ ZLMA update warning (exit code {zlma_result.returncode})")
        except subprocess.TimeoutExpired:
          print("⚠ ZLMA update timed out")
        except Exception as e:
          print(f"⚠ ZLMA update error: {e}")
      else:
        print(f"✗ Failed to resize CPUs for VM '{vm_name}'")
        print(f"HTTP Status: {response.status_code}")
        
    except ValueError:
      print(f"Error: Invalid CPU count '{cpu_count}'. Must be a number between 1-4.")
    except requests.exceptions.ConnectionError:
      print("✗ Cannot connect to Feilong API")
    except Exception as e:
      print(f"✗ Error: {e}")
  
  def _resize_vm_memory(self, vm_name: str, memory_gb: str):
    """Resize VM memory using Feilong API - accepts GB values: 1, 2, 3, 4"""
    try:
      gb_value = int(memory_gb)
      
      if gb_value not in [1, 2, 3, 4]:
        print(f"Error: Memory must be 1, 2, 3, or 4 GB, got: {gb_value}")
        return
      
      api_size = f"{gb_value}g"
      
      print(f"Resizing VM '{vm_name}' to {gb_value}GB memory...")
      
      response = requests.post(
        f"{self.feilong_url}/guests/{vm_name.upper()}/action",
        json={
          "action": "resize_mem",
          "size": api_size
        },
        headers={'Content-Type': 'application/json'},
        timeout=60
      )
      
      if response.status_code == 200:
        print(f"✓ VM '{vm_name}' memory changed to {gb_value}GB")
        print("Note: Changes take effect after VM restart")
        
        # Update ZLMA database after successful memory change
        try:
          print("Updating ZLMA database...")
          zlma_result = subprocess.run("/usr/local/sbin/zlma update", shell=True, capture_output=True, text=True, timeout=30)
          if zlma_result.returncode == 0:
            print("✓ ZLMA database updated successfully")
          else:
            print(f"⚠ ZLMA update warning (exit code {zlma_result.returncode})")
        except subprocess.TimeoutExpired:
          print("⚠ ZLMA update timed out")
        except Exception as e:
          print(f"⚠ ZLMA update error: {e}")
      else:
        print(f"✗ Failed to resize memory for VM '{vm_name}'")
        print(f"HTTP Status: {response.status_code}")
        
    except ValueError:
      print(f"Error: Invalid memory size '{memory_gb}'. Must be 1, 2, 3, or 4.")
    except requests.exceptions.ConnectionError:
      print("✗ Cannot connect to Feilong API")
    except Exception as e:
      print(f"✗ Error: {e}")

  def handle_vm_start(self, vm_name: str, args: List[str]):
    self.log.debug(f"handle_vm_start(): user: {self.conf.user} start vm: {vm_name}")
    print(f"call: 'VIFCMS vm start {vm_name}'")

  def handle_vm_stop(self, vm_name: str, args: List[str]):
    self.log.debug(f"handle_vm_stop(): user: {self.conf.user} stop vm: {vm_name}")
    print(f"call: 'VIFCMS vm stop {vm_name}'")

  def handle_vm_stopall(self):
    self.log.debug(f"handle_vm_stopall(): user: {self.conf.user} stop all VMs")
    print(f"call: 'VIFCMS vm stopall' => better: loop through all images and call 'vm stop' on them")

  def handle_vm_list(self, args: List[str]):
    # List all VMs and their status using Feilong API
    self.log.debug(f"handle_vm_list(): user: {self.conf.user} list all VMs")
    
    try:
      # Call Feilong API to get guests list
      response = requests.get(f"{self.feilong_url}/guests", timeout=10)
      
      if response.status_code == 200:
        data = response.json()
        guests = data.get('output', [])
        
        if guests:
          for guest in guests:
            print(guest)
        else:
          print("No VMs found.")
        
      else:
        print(f"Error: Failed to connect to Feilong API")
        print(f"HTTP Status Code: {response.status_code}")
        print(f"Response: {response.text}")
        
    except requests.exceptions.ConnectTimeout:
      print("Error: Connection to Feilong API timed out")
      print(f"URL: {self.feilong_url}/guests")
    except requests.exceptions.ConnectionError:
      print("Error: Unable to connect to Feilong API")
      print(f"URL: {self.feilong_url}/guests")
    except Exception as e:
      print(f"Error calling Feilong API: {e}")
      print(f"URL: {self.feilong_url}/guests")

  def handle_query_vm(self, vm_name: str):
    # Display configuration of a specific VM
    self.log.debug(f"handle_query_vm() user: {self.conf.user} query VM {vm_name}")
    print(f"Querying VM configuration for: {vm_name}")
    # TODO: Call Feilong API to get VM details
    print("TODO: Implement VM configuration query via Feilong API")

  def handle_query_all(self):
    # Invoke all other query subcommands
    self.log.debug(f"handle_query_all() user: {self.conf.user} run all query commands")
    print("Running all query commands:")
    self.handle_query_active()
    print()
    self.handle_query_configuration()
    print()
    self.handle_query_disks()
    print()
    self.handle_query_errors()
    print()
    self.handle_query_version()
    print()
    self.handle_query_network()
    print()
    self.handle_query_paging()
    print()
    self.handle_query_performance()
    print()
    self.handle_query_shared()
    print()
    self.handle_query_volumes()

  def handle_query_configuration(self):
    # Display current vif settings
    self.log.debug(f"handle_query_configuration() user: {self.conf.user} display vif configuration")
    print("VIF Configuration file /etc/zlma.conf:")
    cmd = "cat /etc/zlma.conf"
    try:
      result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
    except Exception as e:
      print(f"handle_query_configuration(): Exception calling zlma: {e}")
      exit(3)
    print(f"{result.stdout}")              # show the output

  def handle_query_performance(self):
    # Display current CPU, paging and I/O utilization
    self.log.debug(f"handle_query_performance(): user: {self.conf.user} display performance metrics")
    
    print("=== z/VM System Performance Metrics ===")
    print()
    
    try:
      # Run INDICATE command for system performance
      print("System Performance Indicators:")
      print("-" * 35)
      
      ind_output = self.run_vm_cmd("IND")
      if ind_output.strip():
        lines = ind_output.strip().split('\n')
        
        for line in lines:
          line = line.strip()
          if not line:
            continue
            
          # Parse different types of performance data
          if "AVGPROC-" in line:
            # Average processor utilization
            parts = line.split()
            for part in parts:
              if "AVGPROC-" in part:
                cpu_util = part.split("-")[1]
                print(f"Average CPU Utilization: {cpu_util}")
                
          elif "MDC READS-" in line:
            # Memory cache statistics
            print(f"Memory Cache: {line}")
            
          elif "PAGING-" in line:
            # Paging activity
            paging_rate = line.split("-")[1] if "-" in line else "Unknown"
            print(f"Paging Rate: {paging_rate}")
            
          elif line.startswith("Q") and ("DORMANT-" in line or "EXPAN-" in line):
            # Queue statistics
            print(f"Queue Status: {line}")
            
          elif line.startswith("PROC ") and "%" in line:
            # Individual processor utilization
            print(f"Processor Details: {line}")
            
          elif "LIMITED-" in line:
            # Limited resource information
            limited_count = line.split("-")[1] if "-" in line else "Unknown"
            print(f"Limited Resources: {limited_count}")
      else:
        print("No performance indicator data available")
      
      print()
      print("Storage Allocation:")
      print("-" * 20)
      
      # Run QUERY ALLOC MAP for storage allocation
      alloc_output = self.run_vm_cmd("QUERY ALLOC MAP")
      if alloc_output.strip():
        lines = alloc_output.strip().split('\n')
        
        # Find and display header
        header_found = False
        for line in lines:
          line = line.strip()
          if not line:
            continue
            
          # Look for the header line (VOLID RDEV START END TOTAL IN USE HIGH USED TYPE)
          if "VOLID" in line and "RDEV" in line and ("START" in line or "EXTENT" in line):
            print(f"{'VOLID':<8} {'RDEV':<6} {'START':<10} {'END':<10} {'TOTAL':<8} {'IN USE':<8} {'HIGH':<8} {'%':<6} {'TYPE':<12}")
            print("-" * 85)
            header_found = True
            continue
            
          # Skip the separator line and EXTENT header
          if "------" in line or line.startswith("EXTENT"):
            continue
            
          # Display data lines
          if header_found and line:
            # Parse volume information
            parts = line.split()
            if len(parts) >= 8:
              volid = parts[0]
              rdev = parts[1]
              start = parts[2]
              end = parts[3]
              total = parts[4]
              in_use = parts[5]
              high = parts[6]
              percent = parts[7]
              vol_type = ' '.join(parts[8:]) if len(parts) > 8 else ""
              
              print(f"{volid:<8} {rdev:<6} {start:<10} {end:<10} {total:<8} {in_use:<8} {high:<8} {percent:<6} {vol_type:<12}")
      else:
        print("No storage allocation data available")
      
      print()
      print("=" * 50)
      print("Performance Summary:")
      
      # Extract key metrics for summary
      cpu_util = "N/A"
      paging_rate = "N/A"
      total_volumes = 0
      
      if ind_output:
        if "AVGPROC-" in ind_output:
          for part in ind_output.split():
            if "AVGPROC-" in part:
              cpu_util = part.split("-")[1]
              break
        if "PAGING-" in ind_output:
          for part in ind_output.split():
            if "PAGING-" in part:
              paging_rate = part.split("-")[1]
              break
      
      if alloc_output:
        total_volumes = len([line for line in alloc_output.split('\n') 
                           if line.strip() and not any(x in line for x in ['VOLID', 'EXTENT', '------', '']) 
                           and len(line.split()) >= 8])
      
      print(f"CPU Utilization: {cpu_util}")
      print(f"Paging Rate: {paging_rate}")
      print(f"Storage Volumes: {total_volumes}")
      
    except Exception as e:
      print(f"Error querying performance information: {str(e)}")
      self.log.error(f"handle_query_performance(): Error: {e}")

  # New disk command handlers for the new format
  def handle_disk_copy_new(self, options: Dict[str, Any]):
    if options:
      src_vm = options.get('source_vm', '')
      src_disk = options.get('source_disk', '')
      tgt_vm = options.get('target_vm', '')
      tgt_disk = options.get('target_disk', '')
      cmd = f"VIFCMS disk copy {src_vm} {src_disk} {tgt_vm} {tgt_disk}"
      self.log.debug(f"handle_disk_copy_new(): user: {self.conf.user} cmd: {cmd}")
      print(f"call: '{cmd}'")
    else:
      self.log.error("Missing options for disk copy command")
      sys.exit(1)

  def handle_disk_create_new(self, options: Dict[str, Any]):
    if options:
      vm = options.get('vm', '')
      disk_id = options.get('disk_id', '')
      size = options.get('size', '')
      cmd = f"VIFCMS disk create {vm} {disk_id} {size}"
      self.log.debug(f"handle_disk_create_new(): user: {self.conf.user} cmd: {cmd}")
      print(f"call: '{cmd}'")
    else:
      self.log.error("Missing options for disk create command")
      sys.exit(1)

  def handle_disk_delete_new(self, options: Dict[str, Any]):
    if options:
      vm = options.get('vm', '')
      disk_id = options.get('disk_id', '')
      cmd = f"VIFCMS disk delete {vm} {disk_id}"
      self.log.debug(f"handle_disk_delete_new(): user: {self.conf.user} cmd: {cmd}")
      print(f"call: '{cmd}'")
    else:
      self.log.error("Missing options for disk delete command")
      sys.exit(1)

  def handle_disk_share_new(self, options: Dict[str, Any]):
    if options:
      src_vm = options.get('source_vm', '')
      src_disk = options.get('source_disk', '')
      tgt_vm = options.get('target_vm', '')
      tgt_disk = options.get('target_disk', '')
      cmd = f"VIFCMS disk share {src_vm} {src_disk} {tgt_vm} {tgt_disk}"
      self.log.debug(f"handle_disk_share_new(): user: {self.conf.user} cmd: {cmd}")
      print(f"call: '{cmd}'")
    else:
      self.log.error("Missing options for disk share command")
      sys.exit(1)

  # 'vif image' command handlers
  def handle_image_create(self, args):
    args = ' '.join(args)                  # convert dictionary to string
    self.log.debug(f"handle_image_create(): user: {self.conf.user} args {args} clone Linux")
    print(f"call: 'VIFCMS image create {args}' => clone a Linux")

  def handle_image_delete(self, image):
    self.log.debug(f"handle_image_delete(): user: {self.conf.user} ")
    print(f"call: 'VIFCMS image delete {image}' => delete Linux but no PURGE just yet")

  def handle_image_network(self, args):
    args = ' '.join(args)                  # convert dictionary to string
    self.log.debug(f"handle_image_network(): user: {self.conf.user} add/delete network adapters - args: {args}'")
    print(f"call: 'VIFCMS image network {args}' => add OSA triplet - need VSWITCH name as an arg?")

  def handle_image_set(self, args):
    args = ' '.join(args)                  # convert dictionary to string
    self.log.debug(f"handle_image_set(): user: {self.conf.user} update user directory - args: {args}")
    print(f"call: 'VIFCMS image set {args}'")

  def handle_image_start(self, args):
    cmd = f"VIFCMS image start {' '.join(args)}"
    self.log.debug(f"handle_image_start(): user: {self.conf.user} cmd: {cmd}")
    print(f"call: '{cmd}'")

  def handle_image_stop(self, args):
    cmd = f"VIFCMS image stop {' '.join(args)}"
    self.log.debug(f"handle_image_stop(): user: {self.conf.user} cmd: {cmd}")
    print(f"call: '{cmd}'")

  def handle_image_stopall(self):
    cmd = f"VIFCMS image stopall"
    self.log.debug(f"handle_image_stopall(): user: {self.conf.user} SIGNAL SHUTDOWN to all user IDs running Linux'")
    print(f"call: '{cmd}' => better: loop through all images and call 'image stop' on them")

  # 'vif disk' command handlers (legacy)
  def handle_disk_copy(self, args):
    args = ' '.join(args)                  # convert dictionary to string
    cmd = f"VIFCMS disk copy {args}"
    self.log.debug(f"handle_disk_copy(): user: {self.conf.user} cmd: {cmd}")
    print(f"call: '{cmd}'")

  def handle_disk_create(self, args):
    args = ' '.join(args)                  # convert dictionary to string
    cmd = f"VIFCMS disk create {args}"
    self.log.debug(f"handle_disk_create(): user: {self.conf.user} cmd: {cmd}")
    print(f"call: '{cmd}'")

  def handle_disk_delete(self, args):
    args = ' '.join(args)                  # convert dictionary to string
    cmd = f"VIFCMS disk delete {args}"
    self.log.debug(f"handle_disk_delete(): user: {self.conf.user} cmd: {cmd}")
    print(f"call: '{cmd}'")

  def handle_disk_share(self, args):
    args = ' '.join(args)                  # convert dictionary to string
    cmd = f"VIFCMS disk share {args}"
    self.log.debug(f"handle_disk_share(): user: {self.conf.user} cmd: {cmd}")
    print(f"call: '{cmd}'")

  # vif query command handlers
  def handle_query_active(self):
    # Get a list of all VMs in this LPAR
    # Ping each server (1 packet, 500 ms max) and show which are up and which are down
    self.get_lpar_userid()                 # save LPAR and user ID we are running on
    cmd = "/usr/local/sbin/zlma webdata"
    try:
      proc = subprocess.run(cmd, shell=True, capture_output=True, text=True)
    except Exception as e:
      print(f"handle_query_active(): Exception calling zlma: {e}")
      exit(3)
    row_list = proc.stdout.splitlines()
    up_count = 0
    down_count = 0
    for next_row in row_list:
      fields = next_row.split(",")         # split row into list
      ip_addr = fields[3] 
      cmd = f"ping -c1 -W0.5 {ip_addr}"
      proc = subprocess.run(cmd, shell=True, capture_output=True, text=True)
      self.log.debug(f"cmd = {cmd} proc.returncode: {proc.returncode}") 
      if proc.returncode == 0:             # server pings
        fields.append("up")
        up_count += 1
      else:                                # does not ping
        fields.append("down")
        down_count += 1
      row = " ".join(fields)
      print(row)
    print(" ")
    print(f"VMs up  : {up_count}") 
    print(f"VMs down: {down_count}") 

  def handle_query_all(self):
    self.log.debug(f"handle_query_all() user: {self.conf.user} run all other query commands")
    print("handle_query_all() TO DO: call all other query commands")

  def handle_query_errors(self):
    self.log.debug(f"handle_query_errors() user: {self.conf.user} report hardware errors => HMC RESTful API?")
    print("call: 'VIFCMS query errors' => write errors to /var/log/zlma/errors.report.<timestamp>")

  def handle_query_image(self, image):
    self.log.debug(f"handle_query_image() user: {self.conf.user} query image {image}")
    print("TO DO: write this!")

  def handle_query_version(self):
    self.log.debug(f"handle_query_version() user: {self.conf.user} querying system versions")
    
    print("=== System Version Information ===")
    print()
    
    # 1. Get z/VM CP Level
    print("z/VM Control Program Level:")
    print("-" * 30)
    try:
      cp_output = self.run_vm_cmd("QUERY CPLEVEL")
      if cp_output.strip():
        print(cp_output.strip())
      else:
        print("Unable to retrieve z/VM CP level")
    except Exception as e:
      print(f"Error querying z/VM CP level: {e}")
    
    print()
    
    # 2. Get Feilong API Version
    print("Feilong API Version:")
    print("-" * 20)
    try:
      response = requests.get(f"{self.feilong_url}/", timeout=10)
      
      if response.status_code == 200:
        data = response.json()
        
        if data.get('rc') == 0:
          output = data.get('output', {})
          version = output.get('version', 'Unknown')
          api_version = output.get('api_version', 'Unknown')
          max_version = output.get('max_version', 'Unknown')
          min_version = output.get('min_version', 'Unknown')
          
          print(f"Feilong Version: {version}")
          print(f"API Version: {api_version}")
          print(f"Supported API Range: {min_version} - {max_version}")
        else:
          print(f"Error in Feilong response: {data.get('errmsg', 'Unknown error')}")
      else:
        print(f"Failed to connect to Feilong API (HTTP {response.status_code})")
        
    except requests.exceptions.ConnectTimeout:
      print("Timeout connecting to Feilong API")
    except requests.exceptions.ConnectionError:
      print("Cannot connect to Feilong API")
    except Exception as e:
      print(f"Error querying Feilong API: {e}")
    
    print()
    
    # 3. Get ZLMA Version
    print("ZLMA Version:")
    print("-" * 13)
    try:
      # Try to read version from version file - check multiple possible locations
      home_dir = os.path.expanduser("~")
      version_paths = [
        os.path.join(home_dir, 'zlma', 'version'),
        os.path.join(home_dir,'zvm-community-tools', 'zlma', 'version')
      ]
      
      zlma_version = None
      for version_path in version_paths:
        try:
          with open(version_path, 'r') as f:
            zlma_version = f.read().strip()
            print(f"ZLMA Version: {zlma_version}")
            break
        except FileNotFoundError:
          continue
      
      if not zlma_version:
        print("ZLMA version file not found")
            
    except Exception as e:
      print(f"Error reading ZLMA version: {e}")
    
    print()
    
    # 4. Get VIF Script Version (this file)
    print("VIF Command Interface:")
    print("-" * 22)
    print("VIF Version: Part of ZLMA")
    print(f"Configuration: {self.conf.feilong_url}")
    
    print()
    print("=" * 40)

  def handle_query_network(self):
    self.log.debug(f"handle_query_network() user: {self.conf.user} running QUERY VSWITCH DETAILS")
    
    try:
      vmcp_output = self.run_vm_cmd("QUERY VSWITCH DETAILS")
      
      if not vmcp_output.strip():
        print("No VSWITCH information available")
        return
      
      print("=== z/VM VSWITCH Network Information ===")
      print()
      
      # Parse and format the VSWITCH output
      lines = vmcp_output.strip().split('\n')
      current_vswitch = None
      
      for line in lines:
        line = line.strip()
        if not line:
          continue
          
        # Check if this is a VSWITCH header line
        if line.startswith('VSWITCH SYSTEM'):
          if current_vswitch:
            print()  # Add space between VSWITCHes
          current_vswitch = line.split()[2]  # Extract VSWITCH name
          
          # Parse VSWITCH summary info
          parts = line.split()
          vswitch_name = parts[2] if len(parts) > 2 else "Unknown"
          
          # Extract Type, Connected, Maxconn
          type_info = "Unknown"
          connected_info = "0"
          maxconn_info = "Unknown"
          
          for i, part in enumerate(parts):
            if part == "Type:":
              type_info = parts[i+1] if i+1 < len(parts) else "Unknown"
            elif part == "Connected:":
              connected_info = parts[i+1] if i+1 < len(parts) else "0"
            elif part == "Maxconn:":
              maxconn_info = parts[i+1] if i+1 < len(parts) else "Unknown"
          
          print(f"VSWITCH: {vswitch_name}")
          print("-" * (len(vswitch_name) + 9))
          print(f"Type: {type_info}    Connected: {connected_info}    Max Connections: {maxconn_info}")
          
        elif "PERSISTENT" in line or "RESTRICTED" in line:
          # Configuration line
          config_parts = [part.strip() for part in line.split() if part.strip()]
          print(f"Configuration: {' '.join(config_parts)}")
          
        elif "MAC address:" in line:
          # Extract MAC address info
          mac_match = line.split("MAC address:")
          if len(mac_match) > 1:
            mac_info = mac_match[1].strip()
            print(f"MAC Address: {mac_info}")
            
        elif "Uplink Port:" in line:
          print("Uplink Port:")
          
        elif "State:" in line and "Uplink" not in line:
          state = line.split("State:")[1].strip() if "State:" in line else "Unknown"
          print(f"  State: {state}")
          
        elif "RDEV:" in line:
          print(f"  {line}")
          
        elif "Adapter Connections:" in line:
          conn_info = line.split("Connected:")
          connected_count = conn_info[1].strip() if len(conn_info) > 1 else "0"
          print(f"\nAdapter Connections (Connected: {connected_count}):")
          print("-" * 40)
          
        elif "Adapter Owner:" in line:
          # Parse adapter info
          parts = line.split()
          owner = "Unknown"
          nic = "Unknown"
          adapter_type = "Unknown"
          
          for i, part in enumerate(parts):
            if part == "Owner:":
              owner = parts[i+1] if i+1 < len(parts) else "Unknown"
            elif part == "NIC:":
              nic = parts[i+1] if i+1 < len(parts) else "Unknown"
            elif part == "Type:":
              adapter_type = parts[i+1] if i+1 < len(parts) else "Unknown"
          
          print(f"  Owner: {owner}    NIC: {nic}    Type: {adapter_type}")
          
        elif "RX Packets:" in line or "TX Packets:" in line:
          # Traffic statistics
          print(f"    {line}")
          
        elif "RX Bytes:" in line or "TX Bytes:" in line:
          print(f"    {line}")
          
        elif "Unicast MAC Addresses:" in line:
          print("    Unicast MAC Addresses:")
          
        elif "Multicast MAC Addresses:" in line:
          print("    Multicast MAC Addresses:")
          
        elif line.startswith("02-00-00") or line.startswith("01-00-5E") or line.startswith("33-33") or line.startswith("01-80-C2"):
          # MAC address with possible IP
          print(f"      {line}")
          
        elif "Device:" in line and "Unit:" in line:
          print(f"    {line}")
          
        elif "Options:" in line:
          print(f"    {line}")
      
      print("\n" + "=" * 50)
      print("Summary:")
      
      # Count VSWITCHes and total connections
      vswitch_count = vmcp_output.count('VSWITCH SYSTEM')
      print(f"Total VSWITCHes: {vswitch_count}")
      
    except Exception as e:
      print(f"Error querying network information: {str(e)}")
      self.log.error(f"handle_query_network(): Error: {e}")

  def handle_query_paging(self):
    self.log.debug(f"handle_query_paging() user: {self.conf.user} running 'QUERY ALLOC PAGE'")
    print("call: 'VIFCMS query paging'")
    #rc = self.check_privclas("D")          # Q ALLOC requires privilege class D
    #if rc == 1:                            # is privileged
    #  self.log.debug(f"handle_query_paging(): user: {self.conf.user} running QUERY ALLOC PAGE")
    #  self.run_vm_cmd("QUERY ALLOC PAGE")
    #elif rc == 0:                          # is not privileged
    #  self.log.debug(f"handle_query_paging(): user: {self.conf.user} does not have D privclas")
    #  print("You don't have the privilege to query paging")

  def handle_query_disks(self):
    # Display VM DASD utilization using Feilong API
    self.log.debug(f"handle_query_disks() user: {self.conf.user} display VM DASD utilization")
    
    try:
        # Define the pools to query
        pool_types = ["ECKD:VMPOOL", "FBA:VMPOOL"]
        
        print("=== Disk Pool Information ===")
        
        for pool_name in pool_types:
            print(f"<h2>Pool: {pool_name}</h2>")
            
            # First get summary information (without details)
            print(f"<h3>Summary Information</h3>")
            try:
                summary_response = requests.get(
                    f"{self.feilong_url}/host/diskpool",
                    params={'poolname': pool_name},
                    timeout=10
                )
                
                if summary_response.status_code == 200:
                    summary_data = summary_response.json()
                    if summary_data.get('rc') == 0:
                        output = summary_data.get('output', {})
                        
                        # Create summary table
                        print("<table border='1' style='border-collapse: collapse; margin: 10px 0;'>")
                        print("<thead>")
                        print("<tr style='background-color: #1E1E1E;'>")
                        print("<th style='padding: 8px; text-align: left;'>Metric</th>")
                        print("<th style='padding: 8px; text-align: right;'>Size (GB)</th>")
                        print("</tr>")
                        print("</thead>")
                        print("<tbody>")
                        print(f"<tr><td style='padding: 8px;'>Total Pool Size</td><td style='padding: 8px; text-align: right;'>{output.get('disk_total', 'N/A')}</td></tr>")
                        print(f"<tr><td style='padding: 8px;'>Used Space</td><td style='padding: 8px; text-align: right;'>{output.get('disk_used', 'N/A')}</td></tr>")
                        print(f"<tr><td style='padding: 8px;'>Available Space</td><td style='padding: 8px; text-align: right;'>{output.get('disk_available', 'N/A')}</td></tr>")
                        
                        # Calculate and display usage percentage
                        if output.get('disk_total') and output.get('disk_used'):
                            usage_pct = round((output['disk_used'] / output['disk_total']) * 100, 1)
                            print(f"<tr><td style='padding: 8px;'><strong>Usage Percentage</strong></td><td style='padding: 8px; text-align: right;'><strong>{usage_pct}%</strong></td></tr>")
                        
                        print("</tbody>")
                        print("</table>")
                    else:
                        print(f"<p>Error in summary response for {pool_name}: {summary_data.get('errmsg', 'Unknown error')}</p>")
                else:
                    print(f"<p>Failed to get summary for {pool_name}. HTTP Status: {summary_response.status_code}</p>")
            
            except requests.exceptions.Timeout:
                print(f"<p>Timeout getting summary for {pool_name}</p>")
            except requests.exceptions.ConnectionError:
                print(f"<p>Connection error getting summary for {pool_name}</p>")
            except Exception as e:
                print(f"<p>Error getting summary for {pool_name}: {str(e)}</p>")
            
            # Now get detailed information (with details=true)
            print(f"<h3>Detailed Volume Information</h3>")
            try:
                detail_response = requests.get(
                    f"{self.feilong_url}/host/diskpool",
                    params={'poolname': pool_name, 'details': 'true'},
                    timeout=10
                )
                
                if detail_response.status_code == 200:
                    detail_data = detail_response.json()
                    if detail_data.get('rc') == 0:
                        output = detail_data.get('output', {})
                        
                        # Check if we have volume details
                        if isinstance(output, dict) and len(output) > 0:
                            # Display detailed volume information
                            for dasd_group, volumes in output.items():
                                if isinstance(volumes, list) and len(volumes) > 0:
                                    print(f"<h4>DASD Group: {dasd_group}</h4>")
                                    print("<table border='1' style='border-collapse: collapse; margin: 10px 0; width: 100%;'>")
                                    print("<thead>")
                                    print("<tr style='background-color: #1E1E1E;'>")
                                    print("<th style='padding: 8px; text-align: left;'>Volume Name</th>")
                                    print("<th style='padding: 8px; text-align: left;'>Device Type</th>")
                                    print("<th style='padding: 8px; text-align: right;'>Start Cylinder</th>")
                                    print("<th style='padding: 8px; text-align: right;'>Free Size (GB)</th>")
                                    print("<th style='padding: 8px; text-align: left;'>Region Name</th>")
                                    print("</tr>")
                                    print("</thead>")
                                    print("<tbody>")
                                    
                                    total_free = 0
                                    for volume in volumes:
                                        volume_name = volume.get('volume_name', 'N/A')
                                        device_type = volume.get('device_type', 'N/A')
                                        start_cylinder = volume.get('start_cylinder', 'N/A')
                                        free_size = volume.get('free_size', 0)
                                        region_name = volume.get('region_name', 'N/A')
                                        
                                        total_free += free_size if isinstance(free_size, (int, float)) else 0
                                        
                                        print("<tr>")
                                        print(f"<td style='padding: 8px;'>{volume_name}</td>")
                                        print(f"<td style='padding: 8px;'>{device_type}</td>")
                                        print(f"<td style='padding: 8px; text-align: right;'>{start_cylinder}</td>")
                                        print(f"<td style='padding: 8px; text-align: right;'>{free_size}</td>")
                                        print(f"<td style='padding: 8px;'>{region_name}</td>")
                                        print("</tr>")
                                    
                                    # Add summary row for this DASD group
                                    print("<tr style='background-color: #1E1E1E; font-weight: bold;'>")
                                    print(f"<td colspan='3' style='padding: 8px;'>Total Free for {dasd_group}</td>")
                                    print(f"<td style='padding: 8px; text-align: right;'>{total_free} GB</td>")
                                    print("<td style='padding: 8px;'>-</td>")
                                    print("</tr>")
                                    
                                    print("</tbody>")
                                    print("</table>")
                                else:
                                    print(f"<p>No volume details available for DASD group: {dasd_group}</p>")
                        else:
                            print(f"<p>No detailed volume information available for {pool_name}</p>")
                    else:
                        print(f"<p>Error querying details for {pool_name}: {detail_data.get('errmsg', 'Unknown error')}</p>")
                else:
                    print(f"<p>Failed to get details for {pool_name}. HTTP Status: {detail_response.status_code}</p>")
                    
            except requests.exceptions.Timeout:
                print(f"<p>Timeout querying details for {pool_name}</p>")
            except requests.exceptions.ConnectionError:
                print(f"<p>Connection error querying details for {pool_name}</p>")
            except Exception as e:
                print(f"<p>Error querying details for {pool_name}: {str(e)}</p>")
            
            # Add separator between pools
            print("<hr style='margin: 20px 0;'>")
        
        
    except Exception as e:
        print(f"<p>Unexpected error in handle_query_disks: {str(e)}</p>")
        self.log.error(f"handle_query_disks(): Unexpected error: {e}")
        
  def parse_command(self):                 # Parse a command using new parser
    if self.args.verbose:                  # set log level to DEBUG for log file and stdout
      self.log.setLevel(logging.DEBUG)
      self.console.setLevel(logging.DEBUG)
      self.log.debug(f"vif.parse_command() user: {self.conf.user} set log level to verbose")
    cmd =  " ".join(self.args.cmd)
    # print(f"self.lpar: {self.lpar}")
    if self.args.lpar != None:             # LPAR specified
      self.check_lpar(self.args.lpar[0])      # check LPAR where this is running
    self.log.debug(f"parse_command(): user: {self.conf.user} cmd: {cmd}")
    
    # Handle simple help commands first
    match cmd:                             
      case "disk":
        self.handle_help_disk()
        return
      case "help":
        self.handle_help()
        return
      case "hyp" | "hypervisor":
        self.handle_help_hypervisor()
        return
      case "image":
        self.handle_help_image()
        return
      case "vm":
        self.handle_help_vm()
        return
      case "query":
        self.handle_help_query()
        return
      case "help all":
        self.handle_help_all()
        return
      case "help disk":
        self.handle_help_disk()
        return
      case "help hyp" | "help hypervisor":
        self.handle_help_hypervisor()
        return
      case "help image":
        self.handle_help_image()
        return
      case "help vm":
        self.handle_help_vm()
        return
      case "help query":
        self.handle_help_query()
        return
      case _:                              # Parse with new parser
        try:
          parsed_cmd = self.vif_parser.parse(cmd)
          self.dispatch_command(parsed_cmd)
        except ValueError as e:
          self.log.error(f"parse_command(): user: {self.conf.user} Parse error: {e}")
          print(f"Error: {e}")
          sys.exit(1)

# main()
if __name__ == "__main__":
  vif = Vif()                              # create a singleton
  vif.parse_command()                      # process all commands
